---
title: 前后台传参
date: 2022-07-24 15:36:21
categories:
- java
- 网络
description: GET和POST各种传参情况
---

**参考链接：**

- https://blog.csdn.net/m0_50333654/article/details/109632025

```java
import com.fasterxml.jackson.databind.JsonNode;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RestController;
import com.alibaba.fastjson.JSON;
import org.springframework.web.multipart.MultipartFile;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * @Date 2020/9/26 16:04
 * describe: 记录常用的post的传参方式
 */
@RestController
public class PostController {


    // 参数在请求头里的情况
    
    /**
     * 注意: 这种方式PostMapping里的占位符’{id}’,要和接收时参数PathVariable后面括号内的字段一样
     * 请求头: http://127.0.0.1:8080/test/34
     * 请求体:
     * 输出: 34
     */
    @PostMapping("/test/{Id}")
    public void test(@PathVariable("Id") String sid) {
        System.out.println(sid);
    }

    /**
     * 请求头: http://127.0.0.1:8080/test/34/zhangsan
     * 请求体:
     * 输出: id:34,name:zhangsan
     */
    @PostMapping("/test/{Id}/{name}")
    public void test(@PathVariable("Id") String sid, @PathVariable("name") String name) {
        System.out.println("id:" + sid + ",name:" + name);
    }


    // 参数在请求体头和请求体中

	/**
     * 这是一种将请求体中的值封装成Map的方法
     * 请求头: http://127.0.0.1:8080/test1
     * 请求体: {"name","zhangsan"}
     * 输出: zhangsan
     */
    @PostMapping("/test1")
    public void test1(@RequestBody Map<String,Object> map) {
        String name = map.get("name").toString();
        System.out.println(name);
    }

    /**
     * 请求头: http://127.0.0.1:8080/test11
     * 请求体: {"name","zhangsan","age",13}
     * 输出: zhangsan,13
     */
    @PostMapping("/test11")
    public void test11(@RequestBody Map<String,Object> map) {
        String name = map.get("name").toString();
        int age = Integer.parseInt(map.get("age").toString());
        System.out.println(name+","+age);
    }

    /**
     * 注意：这种方式请求体中的"name"要和接收时的参数名称不需要一样
     * 请求头: http://127.0.0.1:8080/test2
     * 请求体: {"name":"zhangsan"}
     * 输出: {"name":"zhangsan"}
     */
    @PostMapping("/test2")
    public void test2(@RequestBody String body) {
        System.out.println(body);
    }

    /**
     * 引入依赖
     * <dependency>
     *   <groupId>com.alibaba</groupId>
     *   <artifactId>fastjson</artifactId>
     *   <version>1.2.72</version>
     * </dependency>
     * */
    /**
     * 请求头: http://127.0.0.1:8080/test21
     * 请求体: {"name":"zhangsan","age":13}
     * 输出: name,zhangsan
     * age,13
     */
    @PostMapping("/test21")
    public void test21(@RequestBody String body) {
        //所有内容都在body中，需要解析出来
        Map map = (Map) JSON.parse(body);
        Set set = map.keySet();
        for (Object k : set) {
            Object v = map.get(k);
            System.out.println(k.toString() + "," + v.toString());
        }
    }

    /**
     * 使用JsonNode来接收，取值时与map取值类似
     * 请求头: http://127.0.0.1:8080/test22
     * 请求体: {"name":"zhangsan","age":13}
     * 输出: zhangsan,13
     */
    @PostMapping("/test22")
    public void test22(@RequestBody JsonNode jsonNode) {
        String name = jsonNode.get("name").asText();
        int age = jsonNode.get("age").asInt();
        System.out.println(name + "," + age);
    }

    /**
     * 注意：Json的自动转换，只能转换简单类，如果类中包含另一个类，则无法自动转换，传入的时候需要把内部类
     * 变成String，然后用JSON.parse()解析出来
     * person类的属性如下
     * private String name;
     * private Integer age;
     * */
    /**
     * 使用实体类来封装，字段匹配上就赋值，没匹配上字段的值就为默认值，比如String的默认值就为null
     * 请求头: http://127.0.0.1:8080/test23
     * 请求体: {"name":"zhangsan","age":13}
     * 输出: Person(name=zhangsan, age=13)
     */
    @PostMapping("/test23")
    public void test23(@RequestBody Person person) {
        System.out.println(person.toString());
    }

    /**
     * 注意：此为类中包含另一个类的解决办法
     * student类的属性如下
     * private String name;
     * private Integer age;
     * private String temporaryString;
     * private List<Score> scoreList;
     * */
    /**
     * 思路：前台传值时把内部的对象转成字符串，类似于"temporaryString":JSON.stringify(对象或对象数组)，我此次用的对象数组
     * 请求头: http://127.0.0.1:8080/test24
     * 请求体: {"name": "zhangsan","age": 13,"temporaryString": "[{'grade':'50'},{'grade':'60'}]"}
     * 输出: Student(name=zhangsan, age=13, temporaryString=[{'grade':'50'},{'grade':'60'}],
     * scoreList=[Score(grade=50), Score(grade=60)])
     */
    @PostMapping("/test24")
    public void test24(@RequestBody Student student) {
        // 拿到字符串，转成Score数组，再塞回Student对象
        String temporaryString = student.getTemporaryString();
        List<Score> scores = JSON.parseArray(temporaryString, Score.class);
        student.setScoreList(scores);
        System.out.println(student.toString());
    }

	/**
     * PathVariable和RequestBody混合使用
     * 请求头: http://127.0.0.1:8080/test3/3
     * 请求体: {"name": "zhangsan"}
     * 输出:
     */
    @PostMapping("/test3/{id}")
    public void test3(@PathVariable("id") String id,  @RequestBody JsonNode jsonNode) {
        String name = jsonNode.get("name").asText();
        System.out.println(id+","+name);
    }


    /**
     * 注意文件上传比较特殊，它并不是以json形式来传递的
     */
    @PostMapping("uploadFile")
    public void upLoadFile(MultipartFile file, String dest) {
        // 获取文件名
        String fileName = file.getOriginalFilename();
    }
}

```



